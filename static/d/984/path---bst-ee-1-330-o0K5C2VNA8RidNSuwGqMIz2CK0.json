{"data":{"markdownRemark":{"html":"<h2>Binary Search Tree</h2>\n<p>Binary Tree is a tree where each node of the tree has up to 2 nodes, left and right. The difference between a binary tree and a binary search tree is how the nodes in a binary search tree is added.</p>\n<blockquote>\n<p>In a binary search tree (BST), the <strong>left</strong> node's value is <strong>smaller or equal</strong> to the current node's value while the <strong>right</strong> node's value is <strong>bigger</strong>.</p>\n</blockquote>\n<p>Thinking of BSTs like the image below is very helpful.</p>\n<p><img src=\"/static/images/bst.png\" width=\"40%\" height=\"50%\">.</p>\n<p>In this writing, I will implement a BST in C++ that looks identical to the image above.</p>\n<p>First, we will define a node of our BST,</p>\n<pre><code class=\"language-cpp\">struct node\n{\n  int val;\n  node *left, *right;\n\n  node(int v)\n  {\n    val = v;\n    left = right = 0;\n  }\n};\n</code></pre>\n<p>Our <code>node</code> data structure has an integer value and left and right pointers. This is because each node will contain a value and also 2 pointers that points to other nodes somewhere in memory.</p>\n<p>Our tree will consist of nodes, right now we have the node defined. Now, we need a function that connects nodes of our tree. This function will get a value and add a new node to our tree with that value.</p>\n<pre><code class=\"language-cpp\">void add(node*&#x26; root, int val)\n{\n  if(!root)\n  {\n    root = new node(val);\n    return;\n  }\n  if(val > root->val)\n    add(root->right, val);\n  else\n    add(root->left, val);\n}\n</code></pre>\n<p>This function traverses through the tree to find the correct spot for the value and creates a new node when it reaches the correct spot.</p>\n<p>The header of this function might look weird, the data type of root is <code>node*&#x26;</code>. What it's doing is <strong>getting a pointer to the root as a reference.</strong> If we don't do this, <code>root</code> will not be changed when the function returns.</p>\n<p>Another way to make it work is to change the header of <code>add</code> to accept root as <code>node**</code>, but then we need to dereference root.</p>\n<p>At this point, we can build a BST using our <code>add</code> function. But, we need a function to display the tree. Some ways to traverse a BST include: inorder, preorder, postorder, breadth-first, and depth-first traversals. We will implement inorder traversal, which will display the values in an ascending order.</p>\n<p>Inorder traversal first prints the value of the left node, then the value of the current node, finally the value of the right node.</p>\n<p><img src=\"/static/images/inOrderTraversal.gif?raw=true\" title=\"Binary Search Tree\"></p>\n<p>Implementation of an inorder traversal will look this:</p>\n<pre><code class=\"language-cpp\">void printInOrder(node* root)\n{\n  if(!root)\n    return;\n  printInOrder(root->left);\n  cout &#x3C;&#x3C; root->val &#x3C;&#x3C; \" \";\n  printInOrder(root->right);\n}\n</code></pre>\n<p>Now, we have everything we need to build and traverse a BST.</p>\n<p>Here's an example of a BST using our <code>add</code> and <code>printInOrder</code> functions.</p>\n<pre><code>node* root = 0;\nadd(root, 10);\nadd(root, 15);\nadd(root, 8);\nadd(root, 18);\nprintInOrder(root);\n</code></pre>\n<blockquote>\n<p>Output: <code>8 10 15 18</code></p>\n</blockquote>\n<p>As we can see, the <code>add</code> function adds new nodes to the tree and <code>printInOrder</code> function traverses the tree starting from the left-most node.</p>","frontmatter":{"date":"November 19, 2018","path":"/bst","title":"Binary Search Tree Implementation"}}},"pageContext":{}}