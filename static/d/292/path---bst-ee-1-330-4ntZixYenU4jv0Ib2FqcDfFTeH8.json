{"data":{"markdownRemark":{"html":"<p>Binary Tree is a tree where each node of the tree has up to 2 nodes, left and right. The difference between a binary tree and a binary search tree is how the nodes in a binary search tree is added.</p>\n<blockquote>\n<p>In a binary search tree (BST), the <strong>left</strong> node's value is <strong>smaller</strong> than the current node's value while the <strong>right</strong> node's value is <strong>bigger or equal to</strong>.</p>\n</blockquote>\n<p>So, the structure of a BST will look like this:</p>\n<img src=\"/static/images/bst.png\" width=\"40%\" height=\"50%\">\n<p>Let's implement a BST in C++ that looks identical to the image above.</p>\n<p>First, we will define a node of our BST,</p>\n<pre><code class=\"language-cpp\">struct node\n{\n  int val;\n  node *left, *right;\n\n  node(int v)\n  {\n    val = v;\n    left = right = 0;\n  }\n};\n</code></pre>\n<p>Our <code>node</code> data structure has an integer value and left and right pointers. That means each node will contain 2 pointers that points to other nodes somewhere in memory.</p>\n<p>Now that <code>node</code> is defined, we need an <code>add</code> function that adds nodes to our tree. The <code>add</code> function starts from the root of the tree and compares the current node's value to our value parameter. If the value of the current node is bigger, then it visits the left child, and vice versa. It does this until the current node is <code>null</code>.</p>\n<p>The <code>add</code> function can be implemented with loops or with recursion. I personally think recursive solutions are more fun than loops, so here's the implementation done with recursion.</p>\n<pre><code class=\"language-cpp\">void add(node*&#x26; root, int val)\n{\n  if(!root)\n  {\n    root = new node(val);\n    return;\n  }\n  if(val >= root->val)\n    add(root->right, val);\n  else\n    add(root->left, val);\n}\n</code></pre>\n<p>The header of this function might look weird, the data type of root is <code>node*&#x26;</code>. What it's doing is getting a pointer to the root as a reference. By doing this, we can directly change the pointers of our tree. If we don't do this, <code>root</code> will not be changed when the function returns.</p>\n<p>Different ways of accomplishing the same thing include: getting a double pointer to the root or returning the updated root from the function.</p>\n<p>At this point, we can build a BST using our <code>add</code> function. But, we need a function to display the tree. Some ways to traverse a BST are inorder, preorder, postorder, breadth-first, and depth-first traversals. We will implement inorder traversal, which will display the values in an ascending order.</p>\n<p>Inorder traversal first visits the left-most node of the tree, then the parent of that node, and finally the right node of that parent. It prints the value of each node it visits.</p>\n<p><img src=\"/static/images/inOrderTraversal.gif?raw=true\" title=\"Binary Search Tree\"></p>\n<p>Implementation of an inorder traversal will look like this:</p>\n<pre><code class=\"language-cpp\">void printInOrder(node* root)\n{\n  if(!root)\n    return;\n  printInOrder(root->left);\n  cout &#x3C;&#x3C; root->val &#x3C;&#x3C; \" \";\n  printInOrder(root->right);\n}\n</code></pre>\n<p>Now, we have everything we need to build and traverse a BST.</p>\n<p>Here's an example of a BST using our <code>add</code> and <code>printInOrder</code> functions.</p>\n<pre><code class=\"language-cpp\">node* root = 0;\nadd(root, 10);\nadd(root, 15);\nadd(root, 8);\nadd(root, 18);\nprintInOrder(root);\n</code></pre>\n<blockquote>\n<p>Output: <code>8 10 15 18</code></p>\n</blockquote>\n<p>As we can see, the <code>add</code> function adds new nodes to the tree and <code>printInOrder</code> function traverses the tree starting from the left-most node.</p>\n<h2>Height of tree</h2>\n<p>Every tree has a height. The tree in the previous image has a height of 4. The <em>deeper</em> the tree grows, the height increases. The algorithm for finding the height can be implemented recursively or with a loop. I prefer the recursive algorithm, which uses divide and conquer.</p>\n<pre><code class=\"language-cpp\">int getHeight(node* head)\n{\n  if(!head)\n    return 0;\n\n  /* get height of left and right nodes */\n  int left = getHeight(head->left);\n  int right = getHeight(head->right);\n\n  /* get the maximum of the left and right nodes and add to it height of current node */\n  return max(left, right) + 1;\n}\n</code></pre>\n<p>The runtime of this algorithm is <code>O(n)</code> (n = number of nodes in tree), there are n subproblems and each subproblem takes a constant time (ignore recursive calls).</p>\n<h2>Searching</h2>\n<p>Breadth First Search (BFS) and Depth First Search (DFS) are two of the essential tree searching algorithms. They differ in their way of traversing the tree, but their implementation is very similar. In fact, if you change the Queue of BFS to a Stack, then you get DFS.</p>\n<pre><code class=\"language-cpp\">void BreadthFirstSearch(node* head)\n{\n  queue&#x3C;node*> q;\n  q.push(head);\n  cout &#x3C;&#x3C; \"BFS: \";\n  /* since it's a tree and not a graph, a visited set is unnecessary */\n  while(!q.empty())\n  {\n    node* temp = q.front();\n    q.pop();\n    cout &#x3C;&#x3C; temp->val &#x3C;&#x3C; \" \";\n    if(temp->left)\n      q.push(temp->left);\n    if(temp->right)\n      q.push(temp->right);\n  }\n  cout &#x3C;&#x3C; endl;\n}\n</code></pre>\n<p><a href=\"https://repl.it/@manlai1025/DFS-and-BFS-in-BST\">Here</a> is the complete code, which contains all the algorithms covered here.</p>","frontmatter":{"date":"November 19, 2018","path":"/bst","title":"Binary Search Tree in C++"}}},"pageContext":{}}