{"data":{"markdownRemark":{"html":"<p>Placing object while checking collisions can done simply with a raycast, but RTS games have a grid under the object which shows whether it can be placed at that spot.</p>\n<img src=\"/static/images/example-building-place.jpg\" width=\"360px\" height=\"270px\">\n<p>The <em><a href=\"https://imgur.com/OmFT6\">image</a></em> above shows Starcraft’s object placement grid.</p>\n<p><strong>This grid needs to be resized based on the object being placed and it must change colors depending on what’s underneath it.</strong> One solution is to get the area of the object and fill it with grid tiles. And that's what we'll do for this implementation.</p>\n<h2>Implementation</h2>\n<h3>Placing objects with a raycast</h3>\n<p>It’s always a good idea to start simple and gradually build up. So, how to place something on a plane?</p>\n<p>To simply place something on a plane can be done with a single function call.</p>\n<pre><code class=\"language-csharp\">[SerializeField] LayerMask layerToRaycast;\n[SerializeField] GameObject object;\n\nvoid RaycastToMouse()\n{\n    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n    RaycastHit hit;\n    if (Physics.Raycast(ray, out hit, Mathf.Infinity, layerToRaycast))\n        object.transform.position = hit.point;\n}\n</code></pre>\n<p>Raycasting this way sends a ray that collides with specific layers that we set in the inspector, which will be very useful in our case. With the above code, we need our plane to be in a specific layer and set <code>layerToRaycast</code> to that layer in the inspector.</p>\n<p>Now, an object can be placed on a plane, but it can be placed on top of other objects. Obviously, this is an issue. There are some solutions to this problem. For this writing, I chose to use <em>layers</em>. This is so that objects, that cannot be placed on top of, can be in the same layer. Using layers is the easiest solution because we wouldn't need any more scripts, we just need to place certain GameObjects in certain layers.</p>\n<h3>BuildingSO (ScriptableObject)</h3>\n<p>I think, having a <code>ScriptableObject</code> for each placeable object is a good way to do it. This <code>ScriptableObject</code> will define everything about the placeable object and the same asset can be later used in multiple cases. For example, if we want to display it in an inventory.</p>\n<p>I think of ScriptableObjects being like <code>struct</code>s. The cool thing about them is that they <strong>can be stored as assets.</strong> I found <a href=\"https://youtu.be/raQ3iHhE_Kk\">this</a> talk about game architectures using ScriptableObjects to be very interesting.</p>\n<p>For this implementation, placeable objects are represented as <code>BuildingSO</code>s that contains their name, prefab, build time, cost, and icon.</p>\n<pre><code class=\"language-csharp\">[CreateAssetMenu(menuName = \"Placeable/Object\")]\npublic class BuildingSO : ScriptableObject\n{\n    public string name;\n    public GameObject buildingPrefab;\n    public float buildTime;\n    public float cost;\n    public Icon icon;\n}\n</code></pre>\n<p>By putting an attribute <code>CreateAssetMenu</code> on top, creating an asset of <code>BuildingSO</code> can be done just like any other Asset!</p>\n<p>I hope at this point, it is clear why ScriptableObjects are useful in this case (we have everything we need to know about the object in one asset!).</p>\n<h3>Grid Tiles</h3>\n<p>So far, objects can be placed on a plane. Actually, it can be placed on anything, I am just using planes for the simplicity. Also, we have a ScriptableObject for the objects that will be placed.</p>\n<p>The problem to solve now is detecting collisions, so that objects cannot be placed on top of some other objects. Remember, the above function for raycasting accepts a layer, which means we can send rays to specific layers. We will use that for the collision grid.</p>\n<p>The grid consists of <em>tiles</em>. Each tile is a <strong>quad that turns green is no collision or red if there’s a collision</strong>.</p>\n<p>One way to do it, we can attach a script to each tile and implements its <code>OnTriggerEnter</code> and <code>OnTriggerExit</code> functions and detect whether the collider lies in the collision layer.</p>\n<pre><code class=\"language-csharp\">[SerializeField] LayerMask collisionLayers;\npublic bool colliding { get; private set; } \n\nvoid OnTriggerEnter(Collider other)\n{\n    if(collisionLayers == (collisionLayers | (1 &#x3C;&#x3C; other.gameObject.layer)))\n    {\n        if(other.gameObject.transform.root.gameObject.GetInstanceID() != transform.root.gameObject.GetInstanceID())\n        {\n            SetColor(Color.red);\n            colliding = true;\n        }\n    }\n}\n\nvoid OnTriggerExit(Collider other)\n{\n    if(collisionLayers == (collisionLayers | (1 &#x3C;&#x3C; other.gameObject.layer)))\n    {\n        SetColor(Color.green);\n        colliding = false;\n    }\n}\n</code></pre>\n<p>After assigning <code>collisionLayers</code> in the inspector, the grid tile will change colors if it collides with an object in <code>collisionLayers</code>.</p>\n<h3>Dynamically resizing grids</h3>\n<p>Now that grid tiles are complete, we need to find a way to <strong>make a grid depending on the size of the placing object</strong>.</p>\n<p>So, let's simplify the problem. We need to somehow <strong>find the area of the GameObject and fill it with grid tiles</strong>. Since we don't want our placeable objects to be built on top of other placeable objects, we send a ray to check. Furthermore, this means each placeable object must have a collider attached to it. Otherwise, raycasts will not work.</p>\n<p>The <code>Collider</code> class has a property called <code>bounds</code> and <code>bounds.extents</code>. We can use these properties to get the area of the collider.</p>\n<pre><code class=\"language-csharp\">[SerializeField] GameObject tileGO;\nGameObject grid;\n\nRect MakeRectOfCollider(Collider col)\n{\n    Rect r = new Rect(col.bounds.center.x - col.bounds.extents.x,\n                    col.bounds.center.z - col.bounds.extents.z,\n                    col.bounds.size.x, col.bounds.size.z);\n    return r;\n}\n\nvoid FillRectWithTiles(Collider col)\n{\n    if(grid)\n        return;\n\n    Rect rect = MakeRectOfCollider(col);\n    float fromX = rect.position.x;\n    float toX = rect.position.x + rect.width;\n    float fromZ = rect.position.y;\n    float toZ = rect.position.y + rect.height;\n\n    GameObject parent = new GameObject(\"Grid\");\n    parent.transform.SetParent(col.gameObject.transform.root);\n    parent.transform.position = col.gameObject.transform.position;\n\n    for(float i = fromX; i &#x3C; toX; i += tileGO.transform.localScale.x)\n        for(float j = fromZ; j &#x3C; toZ; j += tileGO.transform.localScale.y)\n        {\n            GameObject tile = Instantiate(tileGO);\n            tile.transform.SetParent(parent.transform);\n            tile.transform.position = new Vector3(i, parent.transform.position.y + 1, j);\n            activeTiles.Add(tile.GetComponent&#x3C;GridTile>());\n        }\n    grid = parent;\n}\n</code></pre>\n<p>The <code>FillRectWithTiles</code> loops through the rectangle representing the area of the object and spawns grid tiles along the way.</p>\n<h2>End Result</h2>\n<p><img src=\"/static/images/desert.gif?raw=true\" title=\"Placing building in desert\"></p>","frontmatter":{"date":"December 08, 2018","path":"/building-placement","title":"Grid-based object placement in Unity"}}},"pageContext":{}}