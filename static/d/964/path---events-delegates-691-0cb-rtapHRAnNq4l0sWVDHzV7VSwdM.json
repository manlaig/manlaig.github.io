{"data":{"markdownRemark":{"html":"<p>Let’s say you’re writing a function that does something when the user clicks on the mouse. The most obvious solution might be to check if the mouse is clicked in some update function that is called every frame. It might look like:</p>\n<pre><code class=\"language-csharp\">void Update()\n{\n  if(Input.mousePress() > 0)\n     doSomething();\n}\n</code></pre>\n<p>This is okay if you only have one class listening for it. If not, this is very inefficient and it’s a bad code design. Why? Because what if you want other functions in different classes to respond to mouse clicks also. Then, you might have an <code>if</code> statement checking mouse events and calling all those static functions or you might have update functions in each class checking for mouse events. Either way, this is bad code. It’s hard to extend and maintain.</p>\n<p>Events are perfect solutions for this situation.</p>\n<p>Events are one of my favorite features of C#. If you’re coding a game, you want to structure your code, in a way that doesn’t make different components depend on each other, events can be very useful for that. </p>\n<blockquote>\n<p>In short, <strong>events allow you to listen and notify other classes for actions.</strong> </p>\n</blockquote>\n<p>Events depend on <strong>delegates</strong>, to understand events we first need to know about delegates because you can't have events without them.</p>\n<h2>Delegates</h2>\n<blockquote>\n<p><strong>A delegate is a reference type object that holds references to functions.</strong></p>\n</blockquote>\n<p>This is the syntax for declaring a delegate: </p>\n<pre><code class=\"language-csharp\">delegate returnType name([parameters]);\n</code></pre>\n<p>The parameters are optional.</p>\n<p>I mentioned that delegates store functions, so the <code>parameters</code> of a delegate means that the <strong>functions stored in a delegate must have the same parameters as the delegate declaration</strong>.</p>\n<p><strong>The <code>returnType</code> tells what the functions stored in a delegate must return</strong>.</p>\n<p>Here's an example of a delegate in C#:</p>\n<pre><code class=\"language-csharp\">class MainClass\n{\n  delegate void Del();\n  \n  static void func()\n  {\n    Console.WriteLine(\"Func\");\n  }\n  \n  static void func2()\n  {\n    Console.WriteLine(\"Func2\");\n  }\n\n  public static void Main(string[] args)\n  {\n    Del delInstance = null;\n    delInstance += func;\n    delInstance += func2;\n    delInstance();\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>  Func\n  Func2\n</code></pre>\n<p>First, we declare a delegate <code>Del</code> with return type <code>void</code> and no parameters. What that means is that all functions <code>Del</code> stores must have a return type of <code>void</code> and no paremeters. We can see that <code>func</code> and <code>func2</code> satisfies these specifications. So, they can be stored in <code>delInstance</code>.</p>\n<p>Otherwise, <code>delInstance += func;</code> would not work.</p>\n<p>When we run <code>delInstance()</code>, that calls all the functions stored in <code>delInstance</code>, in the order they were added.</p>\n<h2>Events</h2>\n<p>I think of events as being wrapper classes of delegates. They are capable of doing the same thing, but events solve some problems with delegates, which I will demostrate shortly.</p>\n<p>Now that we have a delegate, we can declare an event.</p>\n<p>Here's the syntax for events.</p>\n<pre><code class=\"language-csharp\">event delegateName name;\n</code></pre>\n<p><code>delegateName</code> is the name of the declared delegate, <code>Del</code> in our previous code.</p>\n<blockquote>\n<p><strong>Still writing</strong></p>\n</blockquote>","frontmatter":{"date":"November 11, 2018","path":"/events_delegates","title":"Using Events and Delegates in Unity"}}},"pageContext":{}}