{"data":{"markdownRemark":{"html":"<p>Let’s say you’re writing a function that does something when the user clicks on the mouse. The most obvious solution might be to check if the mouse is clicked in some update function that is called every frame. It might look like:</p>\n<pre><code class=\"language-csharp\">void Update()\n{\n  if(Input.mousePress() > 0)\n     doSomething();\n}\n</code></pre>\n<p>This is okay if you only have one class listening for it. If not, this is very inefficient and it’s a bad code design. Why? Because what if you want other functions in different classes to respond to mouse clicks also. Then, you might have an <code>if</code> statement checking mouse events and calling all those static functions or you might have update functions in each class checking for mouse events. Either way, this is bad code. It’s hard to extend and maintain.</p>\n<p>Events are perfect solutions for this situation.</p>\n<p>Events are one of my favorite features of C#. If you’re coding a game, you want to structure your code, in a way that doesn’t make different components depend on each other, events can be very useful for that. </p>\n<blockquote>\n<p>In short, <strong>events allow you to listen and notify other classes for actions.</strong> </p>\n</blockquote>\n<p>Events depend on <strong>delegates</strong>, to understand events we first need to know about delegates because you can't have events without them.</p>\n<h2>Delegates</h2>\n<blockquote>\n<p><strong>A delegate is a reference type object that holds references to functions.</strong></p>\n</blockquote>\n<p>This is the syntax for declaring a delegate: </p>\n<pre><code class=\"language-csharp\">delegate returnType name([parameters]);\n</code></pre>\n<p>The parameters are optional.</p>\n<p>I mentioned that delegates store functions, so the <code>parameters</code> of a delegate means that the <strong>functions stored in a delegate must have the same parameters as the delegate declaration</strong>.</p>\n<p><strong>The <code>returnType</code> tells what the functions stored in a delegate must return</strong>.</p>\n<p>Here's an example of a delegate in C#:</p>\n<pre><code class=\"language-csharp\">class MainClass\n{\n  delegate void Del();\n  \n  static void func()\n  {\n    Console.WriteLine(\"Func\");\n  }\n  \n  static void func2()\n  {\n    Console.WriteLine(\"Func2\");\n  }\n\n  public static void Main(string[] args)\n  {\n    Del delInstance = null;\n    delInstance += func;\n    delInstance += func2;\n    delInstance();\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>  Func\n  Func2\n</code></pre>\n<p>First, we declare a delegate <code>Del</code> with return type <code>void</code> and no parameters. What that means is that all functions <code>Del</code> stores must have a return type of <code>void</code> and no paremeters. We can see that <code>func</code> and <code>func2</code> satisfies these specifications. So, they can be stored in <code>delInstance</code>.</p>\n<p>Otherwise, <code>delInstance += func;</code> would not work.</p>\n<p>When we run <code>delInstance()</code>, that calls all the functions stored in <code>delInstance</code>, in the order they were added.</p>\n<h2>Events</h2>\n<p>I think of events as being wrapper classes of delegates. They are capable of doing the same thing, but events solve some problems with delegates, which I will demostrate shortly.</p>\n<p>Now that we have a delegate, we can declare an event.</p>\n<p>Here's the syntax for declaring events:</p>\n<pre><code class=\"language-csharp\">event delegateName name;\n</code></pre>\n<p><code>delegateName</code> is the name of the declared delegate, <code>Del</code> in our previous code.</p>\n<p>Using the delegate we declared before, events can be added like this:</p>\n<pre><code class=\"language-csharp\">class Events\n{\n  public delegate void Del();\n  public static event Del e;\n  \n  static void trigger()\n  {\n    if(e != null)\n      e();\n  }\n}\n</code></pre>\n<p><code>trigger()</code> is for triggering the event, this is because <strong>outside the class we can only attach and remove listeners to an event</strong>. Calling the event can only be done in the class the event is defined.</p>\n<p>To use this event in a different class, we need a function that matches the delegate type. For example, </p>\n<pre><code class=\"language-csharp\">class MainClass\n{\n  static void func() { }\n\n  public static void Main (string[] args)\n  {\n    Events.e += func; // attaching to event\n    Events.trigger(); // triggering event\n    Events.e -= func; // removing from event\n  }\n}\n</code></pre>\n<p><strong>The compiler only allows attaching and removing operations when events are used in different classes.</strong></p>\n<p>Creating and using events like this allows us to notify all listeners when event is invoked.</p>\n<p>You can probably already see the benefits of using this design. We can have events, such as <code>playerDead</code>, <code>playerMoved</code>, <code>gameOver</code>, <code>gameStarted</code>, and so on. You can attach a function that does displays the game over text to the <code>playerDead</code> event and it will be called when the event is invoked.</p>\n<h2>Delegates vs Events</h2>\n<p>If you noticed, delegates and events can do the same thing. Both can hold functions and call them when it is invoked.</p>\n<p>As I said earlier, I think of events as wrapper classes of delegates. </p>\n<p>This is because <strong>delegates have a weakness when it comes to making a notification system.</strong></p>\n<p>If you have a public delegate, then you can change its properties in any class. Like setting it to <code>null</code>. This is a serious issue. So, delegates cannot be used to create a notification system because of this.</p>\n<p>On the other hand, events solve this problem of delegates. You can only add and remove functions from events in outside classes. </div></p>","frontmatter":{"date":"November 11, 2018","path":"/events_delegates","title":"Using Events and Delegates in Unity"}}},"pageContext":{}}