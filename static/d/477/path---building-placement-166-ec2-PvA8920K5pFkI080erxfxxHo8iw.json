{"data":{"markdownRemark":{"html":"<p>Placing object while checking collisions can done simply with a raycast, but RTS games have a grid under the object which shows whether it can be placed at that spot.</p>\n<img src=\"/static/images/example-building-place.jpg\" width=\"360px\" height=\"270px\">\n<p>The <em><a href=\"https://imgur.com/OmFT6\">image</a></em> above shows Starcraft’s object placement grid.</p>\n<p><strong>This grid needs to be resized based on the object being placed and it must change colors depending on what’s underneath it.</strong> One solution is to get the area of the object and fill it with grid tiles. And that's what we'll do for this implementation.</p>\n<h1>End Result</h1>\n<p><img src=\"/static/images/desert.gif?raw=true\" title=\"Placing building in desert\"></p>\n<h1>Implementation</h1>\n<h2>Placing objects with a raycast</h2>\n<p>It’s always a good idea to start simple and gradually build up. So, how to place something on a plane?</p>\n<p>To simply place something on a plane can be done with a single function call. </p>\n<pre><code class=\"language-csharp\">[SerializeField] LayerMask layerToRaycast;\n[SerializeField] GameObject object;\n\nvoid RaycastToMouse()\n{\n    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n    RaycastHit hit;\n    if (Physics.Raycast(ray, out hit, Mathf.Infinity, layerToRaycast))\n        object.transform.position = hit.point;\n}\n</code></pre>\n<p>Raycasting this way sends a ray that collides with specific layers that we set in the inspector, which will be very useful in our case. With the above code, we need to our plane to be in a specific layer and set <code>layerToRaycast</code> to that layer in the inspector.</p>\n<p>Now, an object can be placed on a plane, but it can be placed on top of other objects. Obviously, this is an issue. There are many solutions to this problem. There can be a script that is attached to every GameObject that we dont want to place on top of, I think this solution is good if we want our game to expand in the future. But, then we would need a new script. For this writing, I chose to use layers. This is so that objects, that cannot be placed on top of, can be in the same layer.</p>\n<h2>BuildingSO (ScriptableObject)</h2>\n<p>I think, having a <code>ScriptableObject</code> for each placeable object is a good way to do it. This asset will define everything about the placeable object and the same asset can be later used in multiple cases. For example, if we want to display it in an inventory.</p>\n<p>I think of ScriptableObjects being like <code>struct</code>s. The cool thing about them is that they <strong>can be stored as assets.</strong> I found <a href=\"https://youtu.be/raQ3iHhE_Kk\">this</a> talk about game architectures using ScriptableObjects to be very interesting.</p>\n<p>For this implementation, placeable objects are represented as <code>BuildingSO</code>s that contains their name, prefab, cost, and icon.</p>\n<pre><code class=\"language-csharp\">[CreateAssetMenu(menuName = \"Placeable/Object\")]\npublic class BuildingSO : ScriptableObject\n{\n    public string name;\n    public GameObject buildingPrefab;\n    public float cost;\n    public Icon icon;\n}\n</code></pre>\n<p>If we put an attribute <code>CreateAssetMenu</code> on top, creating an asset of <code>BuildingSO</code> can be done just like any other Asset! </p>\n<p>.\n.\n.</p>","frontmatter":{"date":"December 08, 2018","path":"/building-placement","title":"Grid-based object placement in Unity"}}},"pageContext":{}}