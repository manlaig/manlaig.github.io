{"version":3,"sources":["../../src/schema/infer-graphql-type.js"],"names":["require","GraphQLObjectType","GraphQLBoolean","GraphQLString","GraphQLFloat","GraphQLInt","GraphQLList","GraphQLUnionType","_","invariant","oneLine","store","getNode","getNodes","getNodesByType","pageDependencyResolver","createTypeName","createKey","getExampleValues","isEmptyObjectOrArray","INVALID_VALUE","DateType","FileType","is32BitInteger","unionTypes","Map","lazyFields","inferGraphQLType","exampleValue","selector","nodes","types","otherArgs","fieldName","split","pop","shouldInfer","isArray","getListType","getType","Array","inferredType","type","args","resolve","listType","object","context","resolveInfo","fieldValue","map","value","typeName","name","fields","_inferObjectStructureFromNodes","inferFromMapping","mapping","fieldSelector","linkedType","linkedField","slice","length","matchedTypes","filter","isEmpty","console","log","findNode","find","n","get","nodeObjectType","node","a","b","path","findLinkedNodeByField","findLinkedNode","linkedNode","inferFromFieldName","uniqBy","v","internal","key","validateLinkedNode","validateField","field","findNodeType","linkedNodes","forEach","i","f","sort","join","has","description","resolveType","data","set","EXCLUDE_KEYS","id","parent","children","$loki","ignoreFields","config","getState","isRoot","rootTypeName","resolvedExample","inferredFields","each","nextSelector","inferredField","includes","Object","keys","add","sanitizedFieldName","fieldResolve","inferredFieldWithoutResolve","source","inferObjectStructureFromNodes","options","clearUnionTypes","clear"],"mappings":"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","sourcesContent":["// @flow\nconst {\n  GraphQLObjectType,\n  GraphQLBoolean,\n  GraphQLString,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst { oneLine } = require(`common-tags`)\n\nconst { store } = require(`../redux`)\nconst { getNode, getNodes, getNodesByType } = require(`../db/nodes`)\nconst pageDependencyResolver = require(`./page-dependency-resolver`)\nconst createTypeName = require(`./create-type-name`)\nconst createKey = require(`./create-key`)\nconst {\n  getExampleValues,\n  isEmptyObjectOrArray,\n  INVALID_VALUE,\n} = require(`./data-tree-utils`)\nconst DateType = require(`./types/type-date`)\nconst FileType = require(`./types/type-file`)\nconst is32BitInteger = require(`../utils/is-32-bit-integer`)\nconst unionTypes = new Map()\nconst lazyFields = require(`./lazy-fields`)\n\nimport type { GraphQLOutputType } from \"graphql\"\nimport type {\n  GraphQLFieldConfig,\n  GraphQLFieldConfigMap,\n} from \"graphql/type/definition\"\n\nexport type ProcessedNodeType = {\n  name: string,\n  nodes: any[],\n  node: GraphQLFieldConfig<*, *>,\n  fieldsFromPlugins: any,\n  nodeObjectType: GraphQLOutputType,\n}\n\nfunction inferGraphQLType({\n  exampleValue,\n  selector,\n  nodes,\n  types,\n  ...otherArgs\n}): ?GraphQLFieldConfig<*, *> {\n  if (exampleValue == null || isEmptyObjectOrArray(exampleValue)) return null\n  let fieldName = selector.split(`.`).pop()\n\n  // Check this before checking for array as FileType has\n  // builtin support for inferring array of files and inferred\n  // array type will have faster resolver than resolving array\n  // of files separately.\n  if (FileType.shouldInfer(nodes, selector, exampleValue)) {\n    return _.isArray(exampleValue) ? FileType.getListType() : FileType.getType()\n  }\n\n  if (Array.isArray(exampleValue)) {\n    exampleValue = exampleValue[0]\n\n    if (exampleValue == null) return null\n\n    let inferredType = inferGraphQLType({\n      ...otherArgs,\n      exampleValue,\n      selector,\n      nodes,\n      types,\n    })\n    invariant(\n      inferredType,\n      `Could not infer graphQL type for value: ${exampleValue}`\n    )\n\n    const { type, args = null, resolve = null } = inferredType\n\n    const listType = { type: new GraphQLList(type), args }\n\n    if (resolve) {\n      // If inferredType has resolve function wrap it with Array.map\n      listType.resolve = (object, args, context, resolveInfo) => {\n        const fieldValue = object[fieldName]\n        if (!fieldValue) {\n          return null\n        }\n\n        // Field resolver expects first parameter to be plain object\n        // containing key with name of field we want to resolve.\n        return fieldValue.map(value =>\n          resolve({ [fieldName]: value }, args, context, resolveInfo)\n        )\n      }\n    }\n\n    return listType\n  }\n\n  if (\n    // momentjs crashes when it encounters a Symbol,\n    // so check against that\n    typeof exampleValue !== `symbol` &&\n    DateType.shouldInfer(exampleValue)\n  ) {\n    return DateType.getType()\n  }\n\n  switch (typeof exampleValue) {\n    case `boolean`:\n      return { type: GraphQLBoolean }\n    case `string`:\n      return { type: GraphQLString }\n    case `object`: {\n      const typeName = createTypeName(fieldName)\n      return {\n        type: new GraphQLObjectType({\n          name: typeName,\n          fields: _inferObjectStructureFromNodes(\n            {\n              ...otherArgs,\n              selector,\n              nodes,\n              types,\n              typeName,\n            },\n            exampleValue\n          ),\n        }),\n      }\n    }\n    case `number`:\n      return is32BitInteger(exampleValue)\n        ? { type: GraphQLInt }\n        : { type: GraphQLFloat }\n    default:\n      return null\n  }\n}\n\nfunction inferFromMapping(\n  value,\n  mapping,\n  fieldSelector,\n  types\n): ?GraphQLFieldConfig<*, *> {\n  const linkedType = mapping[fieldSelector].split(`.`)[0]\n  const linkedField =\n    mapping[fieldSelector].slice(linkedType.length + 1) || `id`\n\n  const matchedTypes = types.filter(type => type.name === linkedType)\n  if (_.isEmpty(matchedTypes)) {\n    console.log(`Couldn't find a matching node type for \"${fieldSelector}\"`)\n    return null\n  }\n\n  const findNode = fieldValue =>\n    getNodesByType(linkedType).find(n => _.get(n, linkedField) === fieldValue)\n\n  if (_.isArray(value)) {\n    return {\n      type: new GraphQLList(matchedTypes[0].nodeObjectType),\n      resolve: pageDependencyResolver((node, a, b, { fieldName }) => {\n        const fieldValue = node[fieldName]\n        if (fieldValue) {\n          return fieldValue.map(findNode)\n        } else {\n          return null\n        }\n      }),\n    }\n  }\n\n  return {\n    type: matchedTypes[0].nodeObjectType,\n    resolve: (node, a, b, { fieldName }) => {\n      const fieldValue = node[fieldName]\n\n      if (fieldValue) {\n        return findNode(fieldValue, b.path)\n      } else {\n        return null\n      }\n    },\n  }\n}\n\nfunction findLinkedNodeByField(linkedField, value) {\n  getNodes().find(n => n[linkedField] === value)\n}\n\nexport function findLinkedNode(value, linkedField, path) {\n  let linkedNode\n  // If the field doesn't link to the id, use that for searching.\n  if (linkedField) {\n    linkedNode = findLinkedNodeByField(linkedField, value)\n    // Else the field is linking to the node's id, the default.\n  } else {\n    linkedNode = getNode(value)\n  }\n  return linkedNode\n}\n\nfunction inferFromFieldName(value, selector, types): GraphQLFieldConfig<*, *> {\n  let isArray = false\n  if (_.isArray(value)) {\n    isArray = true\n    // Reduce values to nodes with unique types.\n    value = _.uniqBy(value, v => getNode(v).internal.type)\n  }\n\n  const key = selector.split(`.`).pop()\n  const [, , linkedField] = key.split(`___`)\n\n  const validateLinkedNode = linkedNode => {\n    invariant(\n      linkedNode,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding node with the ${linkedField || `id`}\n        field matching: \"${value}\"\n      `\n    )\n  }\n  const validateField = (linkedNode, field) => {\n    invariant(\n      field,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding GraphQL type \"${\n          linkedNode.internal.type\n        }\" available\n        to link to this node.\n      `\n    )\n  }\n\n  const findNodeType = node =>\n    types.find(type => type.name === node.internal.type)\n\n  if (isArray) {\n    const linkedNodes = value.map(getNode)\n    linkedNodes.forEach(node => validateLinkedNode(node))\n    const fields = linkedNodes.map(node => findNodeType(node))\n    fields.forEach((field, i) => validateField(linkedNodes[i], field))\n\n    let type\n    // If there's more than one type, we'll create a union type.\n    if (fields.length > 1) {\n      const typeName = `Union_${key}_${fields\n        .map(f => f.name)\n        .sort()\n        .join(`__`)}`\n\n      if (unionTypes.has(typeName)) {\n        type = unionTypes.get(typeName)\n      }\n\n      if (!type) {\n        type = new GraphQLUnionType({\n          name: createTypeName(`Union_${key}`),\n          description: `Union interface for the field \"${key}\" for types [${fields\n            .map(f => f.name)\n            .sort()\n            .join(`, `)}]`,\n          types: fields.map(f => f.nodeObjectType),\n          resolveType: data =>\n            fields.find(f => f.name == data.internal.type).nodeObjectType,\n        })\n        unionTypes.set(typeName, type)\n      }\n    } else {\n      type = fields[0].nodeObjectType\n    }\n\n    return {\n      type: new GraphQLList(type),\n      resolve: (node, a, b = {}) => {\n        let fieldValue = node[key]\n        if (fieldValue) {\n          return fieldValue.map(value =>\n            findLinkedNode(value, linkedField, b.path)\n          )\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  const linkedNode = findLinkedNode(value, linkedField)\n  validateLinkedNode(linkedNode)\n  const field = findNodeType(linkedNode)\n  validateField(linkedNode, field)\n  return {\n    type: field.nodeObjectType,\n    resolve: pageDependencyResolver(node =>\n      findLinkedNode(node[key], linkedField)\n    ),\n  }\n}\n\ntype inferTypeOptions = {\n  nodes: Object[],\n  types: ProcessedNodeType[],\n  ignoreFields?: string[],\n  selector?: string,\n  typeName?: string,\n}\n\nconst EXCLUDE_KEYS = {\n  id: 1,\n  parent: 1,\n  children: 1,\n  $loki: 1,\n}\n\n// Call this for the top level node + recursively for each sub-object.\n// E.g. This gets called for Markdown and then for its frontmatter subobject.\nfunction _inferObjectStructureFromNodes(\n  { nodes, types, selector, ignoreFields, typeName }: inferTypeOptions,\n  exampleValue: ?Object\n): GraphQLFieldConfigMap<*, *> {\n  const config = store.getState().config\n  const isRoot = !selector\n  const mapping = config && config.mapping\n\n  // Ensure nodes have internal key with object.\n  nodes = nodes.map(n => (n.internal ? n : { ...n, internal: {} }))\n\n  const rootTypeName: string = nodes[0].internal.type\n  if (!typeName) {\n    typeName = rootTypeName\n  }\n\n  let resolvedExample: Object =\n    exampleValue != null\n      ? exampleValue\n      : getExampleValues({ nodes, typeName: rootTypeName, ignoreFields })\n\n  const inferredFields = {}\n  _.each(resolvedExample, (value, key) => {\n    // Remove fields common to the top-level of all nodes.  We add these\n    // elsewhere so don't need to infer their type.\n    if (value === INVALID_VALUE || (isRoot && EXCLUDE_KEYS[key])) return\n\n    // Several checks to see if a field is pointing to custom type\n    // before we try automatic inference.\n    const nextSelector = selector ? `${selector}.${key}` : key\n    const fieldSelector = `${rootTypeName}.${nextSelector}`\n\n    let fieldName = key\n    let inferredField\n\n    // First check for manual field => type mappings in the site's\n    // gatsby-config.js\n    if (mapping && _.includes(Object.keys(mapping), fieldSelector)) {\n      inferredField = inferFromMapping(value, mapping, fieldSelector, types)\n\n      // Second if the field has a suffix of ___node. We use then the value\n      // (a node id) to find the node and use that node's type as the field\n    } else if (key.includes(`___NODE`)) {\n      ;[fieldName] = key.split(`___`)\n      inferredField = inferFromFieldName(value, nextSelector, types)\n      lazyFields.add(typeName, fieldName)\n    }\n\n    // Replace unsupported values\n    const sanitizedFieldName = createKey(fieldName)\n\n    // If a pluging has already provided a type for this, don't infer it.\n    if (ignoreFields && ignoreFields.includes(sanitizedFieldName)) {\n      return\n    }\n\n    // Finally our automatic inference of field value type.\n    if (!inferredField) {\n      inferredField = inferGraphQLType({\n        nodes,\n        types,\n        exampleValue: value,\n        selector: nextSelector,\n      })\n    }\n\n    if (!inferredField) return\n\n    // If sanitized field name is different from original field name\n    // add resolve passthrough to reach value using original field name\n    if (sanitizedFieldName !== fieldName) {\n      const {\n        resolve: fieldResolve,\n        ...inferredFieldWithoutResolve\n      } = inferredField\n\n      // Using copy if field as we sometimes have predefined frozen\n      // field definitions and we can't mutate them.\n      inferredField = inferredFieldWithoutResolve\n\n      if (fieldResolve) {\n        // If field has resolver, call it with adjusted resolveInfo\n        // that points to original field name\n        inferredField.resolve = (source, args, context, resolveInfo) =>\n          fieldResolve(source, args, context, {\n            ...resolveInfo,\n            fieldName: fieldName,\n          })\n      } else {\n        inferredField.resolve = source => source[fieldName]\n      }\n    }\n\n    inferredFields[sanitizedFieldName] = inferredField\n  })\n\n  return inferredFields\n}\n\nexport function inferObjectStructureFromNodes(options: inferTypeOptions) {\n  return _inferObjectStructureFromNodes(options, null)\n}\n\nexport function clearUnionTypes() {\n  unionTypes.clear()\n}\n"],"file":"infer-graphql-type.js"}