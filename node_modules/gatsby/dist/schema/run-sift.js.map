{"version":3,"sources":["../../src/schema/run-sift.js"],"names":["sift","require","_","prepareRegex","Promise","trackInlineObjectsInRootNode","getNode","resolvedNodesCache","Map","enhancedNodeCache","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","awaitSiftField","fields","k","field","resolve","fieldName","undefined","module","exports","nodes","type","typeName","firstOnly","clonedArgs","parse","siftifyArgs","object","newObject","each","v","isPlainObject","Minimatch","mm","makeRe","extractFieldsToSift","prekey","key","preobj","obj","val","forEach","siftArgs","fieldsToSift","filter","includes","push","resolveRecursive","siftFieldsObj","gqFields","all","keys","map","then","innerSift","innerGqConfig","isObject","isFunction","getFields","isArray","ofType","item","resolvedFields","myNode","Object","length","nodesPromise","nodesCacheKey","nodesLength","process","env","NODE_ENV","has","get","cacheKey","enhancedNodeGenerationPromise","resolvedNode","set","resolvedNodes","tempPromise","myNodes","index","isEmpty","indexOf","$and","result","sort","convertedFields","replace","orderBy","order"],"mappings":";;AACA,MAAMA,IAAI,GAAGC,OAAO,CAAE,MAAF,CAApB;;AACA,MAAMC,CAAC,GAAGD,OAAO,CAAE,QAAF,CAAjB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAE,iBAAF,CAA5B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAE,UAAF,CAAvB;;iBACyCA,OAAO,CAAE,iBAAF,C;MAAxCI,4B,YAAAA,4B;;kBACYJ,OAAO,CAAE,aAAF,C;MAAnBK,O,aAAAA,O;;AAER,MAAMC,kBAAkB,GAAG,IAAIC,GAAJ,EAA3B;AACA,MAAMC,iBAAiB,GAAG,IAAID,GAAJ,EAA1B;AACA,MAAME,wBAAwB,GAAG,IAAIF,GAAJ,EAAjC;;AACA,MAAMG,mBAAmB,GAAG,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAC1BD,IAAI,IAAIA,IAAI,CAACE,QAAb,IAAyBF,IAAI,CAACE,QAAL,CAAcC,aAAvC,GACIC,IAAI,CAACC,SAAL;AACEC,EAAAA,MAAM,EAAEN,IAAI,CAACO,EADf;AAEEC,EAAAA,MAAM,EAAER,IAAI,CAACE,QAAL,CAAcC;AAFxB,GAGKF,IAHL,EADJ,GAMI,IAPN;;AASA,SAASQ,cAAT,CAAwBC,MAAxB,EAAgCV,IAAhC,EAAsCW,CAAtC,EAAyC;AACvC,QAAMC,KAAK,GAAGF,MAAM,CAACC,CAAD,CAApB;;AACA,MAAIC,KAAK,CAACC,OAAV,EAAmB;AACjB,WAAOD,KAAK,CAACC,OAAN,CACLb,IADK,EAEL,EAFK,EAGL,EAHK,EAIL;AACEc,MAAAA,SAAS,EAAEH;AADb,KAJK,CAAP;AAQD,GATD,MASO,IAAIX,IAAI,CAACW,CAAD,CAAJ,KAAYI,SAAhB,EAA2B;AAChC,WAAOf,IAAI,CAACW,CAAD,CAAX;AACD;;AAED,SAAOI,SAAP;AACD;AAED;;;;;;;;;;;;;;;AAaAC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAChBhB,EAAAA,IADgB;AAEhBiB,EAAAA,KAFgB;AAGhBC,EAAAA,IAHgB;AAIhBC,EAAAA,QAJgB;AAKhBC,EAAAA,SAAS,GAAG;AALI,CAAD,KAMH;AACZ;AACA;AACA,QAAMC,UAAU,GAAGlB,IAAI,CAACmB,KAAL,CAAWnB,IAAI,CAACC,SAAL,CAAeJ,IAAf,CAAX,CAAnB;;AAEA,QAAMuB,WAAW,GAAGC,MAAM,IAAI;AAC5B,UAAMC,SAAS,GAAG,EAAlB;;AACApC,IAAAA,CAAC,CAACqC,IAAF,CAAOF,MAAP,EAAe,CAACG,CAAD,EAAIjB,CAAJ,KAAU;AACvB,UAAIrB,CAAC,CAACuC,aAAF,CAAgBD,CAAhB,CAAJ,EAAwB;AACtB,YAAIjB,CAAC,KAAM,WAAX,EAAuB;AACrBA,UAAAA,CAAC,GAAI,YAAL;AACD;;AACDe,QAAAA,SAAS,CAACf,CAAD,CAAT,GAAea,WAAW,CAACI,CAAD,CAA1B;AACD,OALD,MAKO;AACL;AACA,YAAIjB,CAAC,KAAM,OAAX,EAAmB;AACjBe,UAAAA,SAAS,CAAE,QAAF,CAAT,GAAsBnC,YAAY,CAACqC,CAAD,CAAlC;AACD,SAFD,MAEO,IAAIjB,CAAC,KAAM,MAAX,EAAkB;AACvB,gBAAMmB,SAAS,GAAGzC,OAAO,CAAE,WAAF,CAAP,CAAqByC,SAAvC;;AACA,gBAAMC,EAAE,GAAG,IAAID,SAAJ,CAAcF,CAAd,CAAX;AACAF,UAAAA,SAAS,CAAE,QAAF,CAAT,GAAsBK,EAAE,CAACC,MAAH,EAAtB;AACD,SAJM,MAIA;AACLN,UAAAA,SAAS,CAAE,IAAGf,CAAE,EAAP,CAAT,GAAqBiB,CAArB;AACD;AACF;AACF,KAlBD;;AAmBA,WAAOF,SAAP;AACD,GAtBD,CALY,CA6BZ;AACA;;;AACA,WAASO,mBAAT,CAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,MAA1C,EAAkDC,GAAlD,EAAuDC,GAAvD,EAA4D;AAC1D,QAAIhD,CAAC,CAACuC,aAAF,CAAgBS,GAAhB,CAAJ,EAA0B;AACxBhD,MAAAA,CAAC,CAACiD,OAAF,CAAWD,GAAX,EAAsB,CAACV,CAAD,EAAIjB,CAAJ,KAAU;AAC9B,YAAIA,CAAC,KAAM,WAAX,EAAuB;AACrB;AACA;AACAsB,UAAAA,mBAAmB,CAACC,MAAD,EAASC,GAAT,EAAcC,MAAd,EAAsBC,GAAtB,EAA2BT,CAA3B,CAAnB;AACA;AACD;;AACDQ,QAAAA,MAAM,CAACF,MAAD,CAAN,GAAiBG,GAAjB;AACAJ,QAAAA,mBAAmB,CAACE,GAAD,EAAMxB,CAAN,EAAS0B,GAAT,EAAc,EAAd,EAAkBT,CAAlB,CAAnB;AACD,OATD;AAUD,KAXD,MAWO;AACLQ,MAAAA,MAAM,CAACF,MAAD,CAAN,GAAiB,IAAjB;AACD;AACF;;AAED,QAAMM,QAAQ,GAAG,EAAjB;AACA,QAAMC,YAAY,GAAG,EAArB;;AACA,MAAInB,UAAU,CAACoB,MAAf,EAAuB;AACrBpD,IAAAA,CAAC,CAACqC,IAAF,CAAOL,UAAU,CAACoB,MAAlB,EAA0B,CAACd,CAAD,EAAIjB,CAAJ,KAAU;AAClC;AACA,UAAIrB,CAAC,CAACqD,QAAF,CAAW,CAAE,MAAF,EAAU,OAAV,EAAmB,MAAnB,CAAX,EAAsChC,CAAtC,CAAJ,EAA8C;AAE9C6B,MAAAA,QAAQ,CAACI,IAAT,CACEpB,WAAW,CAAC;AACV,SAACb,CAAD,GAAKiB;AADK,OAAD,CADb;AAKAK,MAAAA,mBAAmB,CAAE,EAAF,EAAKtB,CAAL,EAAQ,EAAR,EAAY8B,YAAZ,EAA0Bb,CAA1B,CAAnB;AACD,KAVD;AAWD,GA9DW,CAgEZ;;;AACA,WAASiB,gBAAT,CAA0B7C,IAA1B,EAAgC8C,aAAhC,EAA+CC,QAA/C,EAAyD;AACvD,WAAOvD,OAAO,CAACwD,GAAR,CACL1D,CAAC,CAAC2D,IAAF,CAAOH,aAAP,EAAsBI,GAAtB,CAA0BvC,CAAC,IACzBnB,OAAO,CAACqB,OAAR,CAAgBJ,cAAc,CAACsC,QAAD,EAAW/C,IAAX,EAAiBW,CAAjB,CAA9B,EACGwC,IADH,CACQvB,CAAC,IAAI;AACT,YAAMwB,SAAS,GAAGN,aAAa,CAACnC,CAAD,CAA/B;AACA,YAAM0C,aAAa,GAAGN,QAAQ,CAACpC,CAAD,CAA9B;;AACA,UACErB,CAAC,CAACgE,QAAF,CAAWF,SAAX,KACAxB,CAAC,IAAI,IADL,IAEAyB,aAFA,IAGAA,aAAa,CAAClC,IAJhB,EAKE;AACA,YAAI7B,CAAC,CAACiE,UAAF,CAAaF,aAAa,CAAClC,IAAd,CAAmBqC,SAAhC,CAAJ,EAAgD;AAC9C;AACA,iBAAOX,gBAAgB,CACrBjB,CADqB,EAErBwB,SAFqB,EAGrBC,aAAa,CAAClC,IAAd,CAAmBqC,SAAnB,EAHqB,CAAvB;AAKD,SAPD,MAOO,IACLlE,CAAC,CAACmE,OAAF,CAAU7B,CAAV,KACAyB,aAAa,CAAClC,IAAd,CAAmBuC,MADnB,IAEApE,CAAC,CAACiE,UAAF,CAAaF,aAAa,CAAClC,IAAd,CAAmBuC,MAAnB,CAA0BF,SAAvC,CAHK,EAIL;AACA;AACA,iBAAOhE,OAAO,CAACwD,GAAR,CACLpB,CAAC,CAACsB,GAAF,CAAMS,IAAI,IACRd,gBAAgB,CACdc,IADc,EAEdP,SAFc,EAGdC,aAAa,CAAClC,IAAd,CAAmBuC,MAAnB,CAA0BF,SAA1B,EAHc,CADlB,CADK,CAAP;AASD;AACF;;AAED,aAAO5B,CAAP;AACD,KApCH,EAqCGuB,IArCH,CAqCQvB,CAAC,IAAI,CAACjB,CAAD,EAAIiB,CAAJ,CArCb,CADF,CADK,EAyCLuB,IAzCK,CAyCAS,cAAc,IAAI;AACvB,YAAMC,MAAM,qBACP7D,IADO,CAAZ;AAGA4D,MAAAA,cAAc,CAACrB,OAAf,CAAuB,CAAC,CAAC5B,CAAD,EAAIiB,CAAJ,CAAD,KAAaiC,MAAM,CAAClD,CAAD,CAAN,GAAYiB,CAAhD;AACA,aAAOiC,MAAP;AACD,KA/CM,CAAP;AAgDD,GAlHW,CAoHZ;AACA;;;AACA,MACExC,SAAS,IACTyC,MAAM,CAACb,IAAP,CAAYR,YAAZ,EAA0BsB,MAA1B,KAAqC,CADrC,IAEAD,MAAM,CAACb,IAAP,CAAYR,YAAZ,EAA0B,CAA1B,MAAkC,IAFlC,IAGAqB,MAAM,CAACb,IAAP,CAAYT,QAAQ,CAAC,CAAD,CAAR,CAAYjC,EAAxB,EAA4BwD,MAA5B,KAAuC,CAHvC,IAIAD,MAAM,CAACb,IAAP,CAAYT,QAAQ,CAAC,CAAD,CAAR,CAAYjC,EAAxB,EAA4B,CAA5B,MAAoC,KALtC,EAME;AACA,WAAOsC,gBAAgB,CACrBnD,OAAO,CAAC8C,QAAQ,CAAC,CAAD,CAAR,CAAYjC,EAAZ,CAAgB,KAAhB,CAAD,CADc,EAErBkC,YAFqB,EAGrBtB,IAAI,CAACqC,SAAL,EAHqB,CAAhB,CAILL,IAJK,CAIAnD,IAAI,IAAKA,IAAI,GAAG,CAACA,IAAD,CAAH,GAAY,EAJzB,CAAP;AAKD;;AAED,QAAMgE,YAAY,GAAG,MAAM;AACzB,UAAMC,aAAa,GAAG7D,IAAI,CAACC,SAAL;AACpB;AACA;AACAe,MAAAA,QAHoB;AAIpB8C,MAAAA,WAAW,EAAEhD,KAAK,CAAC6C;AAJC,OAKjBtB,YALiB,EAAtB;;AAOA,QACE0B,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAA0B,YAA1B,IACA1E,kBAAkB,CAAC2E,GAAnB,CAAuBL,aAAvB,CAFF,EAGE;AACA,aAAOzE,OAAO,CAACqB,OAAR,CAAgBlB,kBAAkB,CAAC4E,GAAnB,CAAuBN,aAAvB,CAAhB,CAAP;AACD,KALD,MAKO;AACL,aAAOzE,OAAO,CAACwD,GAAR,CACL9B,KAAK,CAACgC,GAAN,CAAUlD,IAAI,IAAI;AAChB,cAAMwE,QAAQ,GAAGzE,mBAAmB,CAAC;AACnCC,UAAAA,IADmC;AAEnCC,UAAAA,IAAI,EAAEwC;AAF6B,SAAD,CAApC;;AAIA,YAAI+B,QAAQ,IAAI3E,iBAAiB,CAACyE,GAAlB,CAAsBE,QAAtB,CAAhB,EAAiD;AAC/C,iBAAOhF,OAAO,CAACqB,OAAR,CAAgBhB,iBAAiB,CAAC0E,GAAlB,CAAsBC,QAAtB,CAAhB,CAAP;AACD,SAFD,MAEO,IAAIA,QAAQ,IAAI1E,wBAAwB,CAACwE,GAAzB,CAA6BE,QAA7B,CAAhB,EAAwD;AAC7D,iBAAO1E,wBAAwB,CAACyE,GAAzB,CAA6BC,QAA7B,CAAP;AACD;;AAED,cAAMC,6BAA6B,GAAG,IAAIjF,OAAJ,CAAYqB,OAAO,IAAI;AAC3DgC,UAAAA,gBAAgB,CAAC7C,IAAD,EAAOyC,YAAP,EAAqBtB,IAAI,CAACqC,SAAL,EAArB,CAAhB,CAAuDL,IAAvD,CACEuB,YAAY,IAAI;AACdjF,YAAAA,4BAA4B,CAACiF,YAAD,CAA5B;;AACA,gBAAIF,QAAJ,EAAc;AACZ3E,cAAAA,iBAAiB,CAAC8E,GAAlB,CAAsBH,QAAtB,EAAgCE,YAAhC;AACD;;AACD7D,YAAAA,OAAO,CAAC6D,YAAD,CAAP;AACD,WAPH;AASD,SAVqC,CAAtC;AAWA5E,QAAAA,wBAAwB,CAAC6E,GAAzB,CAA6BH,QAA7B,EAAuCC,6BAAvC;AACA,eAAOA,6BAAP;AACD,OAxBD,CADK,EA0BLtB,IA1BK,CA0BAyB,aAAa,IAAI;AACtBjF,QAAAA,kBAAkB,CAACgF,GAAnB,CAAuBV,aAAvB,EAAsCW,aAAtC;AACA,eAAOA,aAAP;AACD,OA7BM,CAAP;AA8BD;AACF,GA7CD;;AA8CA,QAAMC,WAAW,GAAGb,YAAY,GAAGb,IAAf,CAAoB2B,OAAO,IAAI;AACjD,QAAIzD,SAAJ,EAAe;AACb,YAAM0D,KAAK,GAAGzF,CAAC,CAAC0F,OAAF,CAAUxC,QAAV,IACV,CADU,GAEVpD,IAAI,CAAC6F,OAAL,CACE;AACEC,QAAAA,IAAI,EAAE1C;AADR,OADF,EAIEsC,OAJF,CAFJ;;AASA,UAAIC,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,eAAO,CAACD,OAAO,CAACC,KAAD,CAAR,CAAP;AACD,OAFD,MAEO;AACL,eAAO,EAAP;AACD;AACF,KAfD,MAeO;AACL,UAAII,MAAM,GAAG7F,CAAC,CAAC0F,OAAF,CAAUxC,QAAV,IACTsC,OADS,GAET1F,IAAI,CACF;AACE8F,QAAAA,IAAI,EAAE1C;AADR,OADE,EAIFsC,OAJE,CAFR;AASA,UAAI,CAACK,MAAD,IAAW,CAACA,MAAM,CAACpB,MAAvB,EAA+B,OAAO,IAAP,CAV1B,CAYL;;AACA,UAAIzC,UAAU,CAAC8D,IAAf,EAAqB;AACnB;AACA;AACA,cAAMC,eAAe,GAAG/D,UAAU,CAAC8D,IAAX,CAAgB1E,MAAhB,CACrBwC,GADqB,CACjBtC,KAAK,IAAIA,KAAK,CAAC0E,OAAN,CAAc,MAAd,EAAuB,GAAvB,CADQ,EAErBpC,GAFqB,CAEjBtC,KAAK,IAAIgB,CAAC,IAAItC,CAAC,CAACiF,GAAF,CAAM3C,CAAN,EAAShB,KAAT,CAFG,CAAxB;AAIAuE,QAAAA,MAAM,GAAG7F,CAAC,CAACiG,OAAF,CAAUJ,MAAV,EAAkBE,eAAlB,EAAmC/D,UAAU,CAAC8D,IAAX,CAAgBI,KAAnD,CAAT;AACD;;AACD,aAAOL,MAAP;AACD;AACF,GAxCmB,CAApB;AA0CA,SAAON,WAAP;AACD,CAnOD","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`./prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`./node-tracking`)\nconst { getNode } = require(`../db/nodes`)\n\nconst resolvedNodesCache = new Map()\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(\n      node,\n      {},\n      {},\n      {\n        fieldName: k,\n      }\n    )\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over\n * @param type gqlType\n * @param typeName\n * @param firstOnly true if you want to return only the first result\n * found. This will return a collection of size 1. Not a single\n * element\n * @returns Collection of results. Collection will be limited to size\n * if `firstOnly` is true\n */\nmodule.exports = ({\n  args,\n  nodes,\n  type,\n  typeName,\n  firstOnly = false,\n}: Object) => {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const clonedArgs = JSON.parse(JSON.stringify(args))\n\n  const siftifyArgs = object => {\n    const newObject = {}\n    _.each(object, (v, k) => {\n      if (_.isPlainObject(v)) {\n        if (k === `elemMatch`) {\n          k = `$elemMatch`\n        }\n        newObject[k] = siftifyArgs(v)\n      } else {\n        // Compile regex first.\n        if (k === `regex`) {\n          newObject[`$regex`] = prepareRegex(v)\n        } else if (k === `glob`) {\n          const Minimatch = require(`minimatch`).Minimatch\n          const mm = new Minimatch(v)\n          newObject[`$regex`] = mm.makeRe()\n        } else {\n          newObject[`$${k}`] = v\n        }\n      }\n    })\n    return newObject\n  }\n\n  // Build an object that excludes the innermost leafs,\n  // this avoids including { eq: x } when resolving fields.\n  function extractFieldsToSift(prekey, key, preobj, obj, val) {\n    if (_.isPlainObject(val)) {\n      _.forEach((val: any), (v, k) => {\n        if (k === `elemMatch`) {\n          // elemMatch is operator for arrays and not field we want to prepare\n          // so we need to skip it\n          extractFieldsToSift(prekey, key, preobj, obj, v)\n          return\n        }\n        preobj[prekey] = obj\n        extractFieldsToSift(key, k, obj, {}, v)\n      })\n    } else {\n      preobj[prekey] = true\n    }\n  }\n\n  const siftArgs = []\n  const fieldsToSift = {}\n  if (clonedArgs.filter) {\n    _.each(clonedArgs.filter, (v, k) => {\n      // Ignore connection and sorting args.\n      if (_.includes([`skip`, `limit`, `sort`], k)) return\n\n      siftArgs.push(\n        siftifyArgs({\n          [k]: v,\n        })\n      )\n      extractFieldsToSift(``, k, {}, fieldsToSift, v)\n    })\n  }\n\n  // Resolves every field used in the node.\n  function resolveRecursive(node, siftFieldsObj, gqFields) {\n    return Promise.all(\n      _.keys(siftFieldsObj).map(k =>\n        Promise.resolve(awaitSiftField(gqFields, node, k))\n          .then(v => {\n            const innerSift = siftFieldsObj[k]\n            const innerGqConfig = gqFields[k]\n            if (\n              _.isObject(innerSift) &&\n              v != null &&\n              innerGqConfig &&\n              innerGqConfig.type\n            ) {\n              if (_.isFunction(innerGqConfig.type.getFields)) {\n                // this is single object\n                return resolveRecursive(\n                  v,\n                  innerSift,\n                  innerGqConfig.type.getFields()\n                )\n              } else if (\n                _.isArray(v) &&\n                innerGqConfig.type.ofType &&\n                _.isFunction(innerGqConfig.type.ofType.getFields)\n              ) {\n                // this is array\n                return Promise.all(\n                  v.map(item =>\n                    resolveRecursive(\n                      item,\n                      innerSift,\n                      innerGqConfig.type.ofType.getFields()\n                    )\n                  )\n                )\n              }\n            }\n\n            return v\n          })\n          .then(v => [k, v])\n      )\n    ).then(resolvedFields => {\n      const myNode = {\n        ...node,\n      }\n      resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n      return myNode\n    })\n  }\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (\n    firstOnly &&\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id` &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  ) {\n    return resolveRecursive(\n      getNode(siftArgs[0].id[`$eq`]),\n      fieldsToSift,\n      type.getFields()\n    ).then(node => (node ? [node] : []))\n  }\n\n  const nodesPromise = () => {\n    const nodesCacheKey = JSON.stringify({\n      // typeName + count being the same is a pretty good\n      // indication that the nodes are the same.\n      typeName,\n      nodesLength: nodes.length,\n      ...fieldsToSift,\n    })\n    if (\n      process.env.NODE_ENV === `production` &&\n      resolvedNodesCache.has(nodesCacheKey)\n    ) {\n      return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n    } else {\n      return Promise.all(\n        nodes.map(node => {\n          const cacheKey = enhancedNodeCacheId({\n            node,\n            args: fieldsToSift,\n          })\n          if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n            return Promise.resolve(enhancedNodeCache.get(cacheKey))\n          } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n            return enhancedNodePromiseCache.get(cacheKey)\n          }\n\n          const enhancedNodeGenerationPromise = new Promise(resolve => {\n            resolveRecursive(node, fieldsToSift, type.getFields()).then(\n              resolvedNode => {\n                trackInlineObjectsInRootNode(resolvedNode)\n                if (cacheKey) {\n                  enhancedNodeCache.set(cacheKey, resolvedNode)\n                }\n                resolve(resolvedNode)\n              }\n            )\n          })\n          enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n          return enhancedNodeGenerationPromise\n        })\n      ).then(resolvedNodes => {\n        resolvedNodesCache.set(nodesCacheKey, resolvedNodes)\n        return resolvedNodes\n      })\n    }\n  }\n  const tempPromise = nodesPromise().then(myNodes => {\n    if (firstOnly) {\n      const index = _.isEmpty(siftArgs)\n        ? 0\n        : sift.indexOf(\n            {\n              $and: siftArgs,\n            },\n            myNodes\n          )\n\n      if (index !== -1) {\n        return [myNodes[index]]\n      } else {\n        return []\n      }\n    } else {\n      let result = _.isEmpty(siftArgs)\n        ? myNodes\n        : sift(\n            {\n              $and: siftArgs,\n            },\n            myNodes\n          )\n\n      if (!result || !result.length) return null\n\n      // Sort results.\n      if (clonedArgs.sort) {\n        // create functions that return the item to compare on\n        // uses _.get so nested fields can be retrieved\n        const convertedFields = clonedArgs.sort.fields\n          .map(field => field.replace(/___/g, `.`))\n          .map(field => v => _.get(v, field))\n\n        result = _.orderBy(result, convertedFields, clonedArgs.sort.order)\n      }\n      return result\n    }\n  })\n\n  return tempPromise\n}\n"],"file":"run-sift.js"}