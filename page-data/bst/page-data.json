{"componentChunkName":"component---src-templates-blog-post-js","path":"/bst","webpackCompilationHash":"05caf6b36212b63f6632","result":{"data":{"markdownRemark":{"html":"<h2>Binary Search Tree</h2>\n<p>Binary Tree is a tree where each node of the tree has up to 2 nodes, left and right. The difference between a binary tree and a binary search tree is how the nodes in the tree are added.</p>\n<blockquote>\n<p>In a binary search tree (BST), the <strong>left</strong> node's value is <strong>smaller</strong> than its' parent node's value while the <strong>right</strong> node's value is <strong>bigger or equal</strong>.</p>\n</blockquote>\n<p>Here is an illustration of how to think about BSTs.</p>\n<p><img src=\"./bst.png?raw=true\" title=\"Binary Search Tree\"></p>\n<p>In this writing, I will implement a BST in C++ that looks identical to the image above. [Here] (<a href=\"https://repl.it/@manlai1025/Binary-Search-Tree-delete\">https://repl.it/@manlai1025/Binary-Search-Tree-delete</a>) is the finished implementation.</p>\n<p>First, we will define a node of our BST,</p>\n<pre><code class=\"language-cpp\">struct node\n{\n  int val;\n  node *left, *right;\n\n  node(int v) : val(v)\n  {\n    left = right = 0;\n  }\n};\n</code></pre>\n<p>Our <code>node</code> structure has an integer value and left and right pointers. This is because each node will contain a value and also 2 pointers that points to 2 child nodes stored somewhere in memory.</p>\n<p>Our tree will consist of nodes, right now we have the node defined. Now, we need a function that connects nodes of our tree. This function will get a value and add a new node to our tree with that value.</p>\n<pre><code class=\"language-cpp\">void add(node*&#x26; root, int val)\n{\n  if(!root)\n  {\n    root = new node(val);\n    return;\n  }\n  if(val > root->val)\n    add(root->right, val);\n  else\n    add(root->left, val);\n}\n</code></pre>\n<p>This recursive function traverses through the tree to find the correct spot for the value and creates a new leaf node when it reaches the correct spot, which is when root=null.</p>\n<p>The header of this function might look weird, the data type of root is <code>node*&#x26;</code>. What this is doing is getting a pointer to the root as a <strong>reference.</strong> Another way can be to get the root as a <strong>double pointer</strong>. By doing this, we can edit where the pointers of our tree is pointing to.</p>\n<p>With the <code>add</code> function, we can now build a BST. But, we need a function to print sthe tree. Some algorithms to traverse a tree include: inorder, preorder, postorder, breadth-first, and depth-first traversals. We will implement inorder traversal, which will display the values of our tree in an ascending order.</p>\n<p>Inorder traversal first prints the value of the left node, then the value of the current node, finally the value of the right node.</p>\n<p><img src=\"./inOrderTraversal.gif?raw=true\" title=\"Binary Search Tree\"></p>\n<p>Implementation of an inorder traversal will look like this:</p>\n<pre><code class=\"language-cpp\">void printInOrder(node* root)\n{\n  if(!root)\n    return;\n  printInOrder(root->left);\n  cout &#x3C;&#x3C; root->val &#x3C;&#x3C; \" \";\n  printInOrder(root->right);\n}\n</code></pre>\n<p>Now, we have everything we need to build and traverse a BST.</p>\n<p>Here's an example of a BST using our <code>add</code> and <code>printInOrder</code> functions.</p>\n<pre><code>node* root = 0;\nadd(root, 10);\nadd(root, 15);\nadd(root, 8);\nadd(root, 18);\nprintInOrder(root);\n</code></pre>\n<blockquote>\n<p>Output: <code>8 10 15 18</code></p>\n</blockquote>\n<p>As we can see, the <code>add</code> function adds new nodes to the tree and <code>printInOrder</code> function traverses the tree starting from the left-most node.</p>","frontmatter":{"date":"November 19, 2018","path":"/bst","title":"Binary Search Tree Implementation"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}