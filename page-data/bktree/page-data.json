{"componentChunkName":"component---src-templates-blog-post-js","path":"/bktree","webpackCompilationHash":"1e0715b5b28e093e7473","result":{"data":{"markdownRemark":{"html":"<h2>BK-Tree</h2>\n<p>BK-Tree or Burkhard Keller Tree is a data structure used to perform spell checks. In other words, a data structure used to return the closest match to a certain word. For example, suppose your tree consists of words \"hello, helllo\". Then, if searched for \"helo\", it would return \"hello.\"</p>\n<p><a href=\"https://repl.it/@manlai1025/BK-Tree\">Here</a> is the finished implementation in C++.</p>\n<h3>Edit Distance (Levenshtein Distance)</h3>\n<p>BK-Trees work based on the edit distance algorithm. The edit distance problem is as follows: If you're allowed to append/delete a character or replace a character with another, find the minimum number of transforms required to transform one string into the other.</p>\n<p><a href=\"https://repl.it/@manlai1025/Levenshtein-Distance-algorithm\">Here</a> are implementations of the Levenshtein distance algorithm using the efficient dynamic programming approach and the inefficient recursion approach. I have documented it well, so it's helpful to go through it.</p>\n<h3>Adding a new node</h3>\n<p>Suppose you want to add the word <code>str</code> to the tree, knowing the <code>root</code>.</p>\n<p>First, compute the Levenshtein Distance between <code>str</code> and <code>root.str</code>. This value tells you the edit distance between the word you want to add and the value of the root. </p>","frontmatter":{"date":"January 22, 2019","path":"/bktree","title":"Awesome Data Structures, BK-Tree"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}