<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/component---src-templates-blog-post-js.843d075df3c042fb76ca.css">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0;background:#f0f0f0;vertical-align:middle}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:1.75rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.5rem}h3{font-size:1.35rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,p{padding:0;margin:0 0 1.45rem}p{font-family:Georgia,Times New Roman,Times,serif;font-size:20px;font-weight:500}figure{padding:0}figure,pre{margin:0 0 1.45rem}pre{font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}.nav{position:fixed;width:100%}.name{font-size:28px;letter-spacing:.5px;font-weight:500}#card-blog{width:auto;display:flex;margin-bottom:25px}#card-blog,#card-projects{transition:all .3s cubic-bezier(.25,.8,.25,1)}#card-blog:hover,#card-projects:hover{box-shadow:0 7px 16px rgba(0,0,0,.2),0 6px 7px rgba(0,0,0,.2)}#quote{margin-bottom:25px;font-size:18px;text-align:center}</style><meta name="generator" content="Gatsby 2.0.79"/><title data-react-helmet="true">Binary Search Tree in C++</title><link as="script" rel="preload" href="/component---src-templates-blog-post-js-ea0b0e9e48edfbee761b.js"/><link as="script" rel="preload" href="/0-f46980da95ff899b1c80.js"/><link as="script" rel="preload" href="/app-222f29cc36792ce09b0f.js"/><link as="script" rel="preload" href="/webpack-runtime-45262e1a2370d384551a.js"/><link as="fetch" rel="preload" href="/static/d/292/path---bst-ee-1-330-4ntZixYenU4jv0Ib2FqcDfFTeH8.json" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="jss1" class="nav"><header class="jss15 jss21 jss6 jss7 jss13 mui-fixed" style="background:#363640"><div class="jss42 jss44 jss43"><a title="Go to Home" style="text-decoration:none;color:#FFF" href="/"><div class="name">Michael Ganzorig</div></a><div class="jss2"></div><div class="jss4"><a style="font-size:22px;text-decoration:none;color:rgba(255,255,255,0.75);margin-right:20px" href="/"><svg class="jss46" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></svg></a><a style="font-size:22px;text-decoration:none;color:rgba(255,255,255,0.75);margin-right:20px" href="/about">About</a><a style="font-size:22px;text-decoration:none;color:rgba(255,255,255,0.75);margin-right:20px" href="/projects">Projects</a><a style="font-size:22px;text-decoration:none;color:rgba(255,255,255,0.75);margin-right:20px" href="/blog">Writing</a></div><div class="jss5"><button class="jss61 jss55 jss56" tabindex="0" type="button"><span class="jss60"><a style="color:rgba(255,255,255,1)" href="/"><svg class="jss46" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></svg></a></span></button><button class="jss61 jss55 jss56" tabindex="0" type="button" aria-haspopup="true"><span class="jss60"><svg class="jss46" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path fill="none" d="M0 0h24v24H0z"></path><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span></button></div></div></header></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:100px"><div><div><h1>Binary Search Tree in C++</h1><div style="letter-spacing:0.2px"><p>Binary Tree is a tree where each node of the tree has up to 2 nodes, left and right. The difference between a binary tree and a binary search tree is how the nodes in a binary search tree is added.</p>
<blockquote>
<p>In a binary search tree (BST), the <strong>left</strong> node's value is <strong>smaller</strong> than the current node's value while the <strong>right</strong> node's value is <strong>bigger or equal to</strong>.</p>
</blockquote>
<p>So, the structure of a BST will look like this:</p>
<img src="/static/images/bst.png" width="40%" height="50%">
<p>Let's implement a BST in C++ that looks identical to the image above.</p>
<p>First, we will define a node of our BST,</p>
<pre><code class="language-cpp">struct node
{
  int val;
  node *left, *right;

  node(int v)
  {
    val = v;
    left = right = 0;
  }
};
</code></pre>
<p>Our <code>node</code> data structure has an integer value and left and right pointers. That means each node will contain 2 pointers that points to other nodes somewhere in memory.</p>
<p>Now that <code>node</code> is defined, we need an <code>add</code> function that adds nodes to our tree. The <code>add</code> function starts from the root of the tree and compares the current node's value to our value parameter. If the value of the current node is bigger, then it visits the left child, and vice versa. It does this until the current node is <code>null</code>.</p>
<p>The <code>add</code> function can be implemented with loops or with recursion. I personally think recursive solutions are more fun than loops, so here's the implementation done with recursion.</p>
<pre><code class="language-cpp">void add(node*&#x26; root, int val)
{
  if(!root)
  {
    root = new node(val);
    return;
  }
  if(val >= root->val)
    add(root->right, val);
  else
    add(root->left, val);
}
</code></pre>
<p>The header of this function might look weird, the data type of root is <code>node*&#x26;</code>. What it's doing is getting a pointer to the root as a reference. By doing this, we can directly change the pointers of our tree. If we don't do this, <code>root</code> will not be changed when the function returns.</p>
<p>Different ways of accomplishing the same thing include: getting a double pointer to the root or returning the updated root from the function.</p>
<p>At this point, we can build a BST using our <code>add</code> function. But, we need a function to display the tree. Some ways to traverse a BST are inorder, preorder, postorder, breadth-first, and depth-first traversals. We will implement inorder traversal, which will display the values in an ascending order.</p>
<p>Inorder traversal first visits the left-most node of the tree, then the parent of that node, and finally the right node of that parent. It prints the value of each node it visits.</p>
<p><img src="/static/images/inOrderTraversal.gif?raw=true" title="Binary Search Tree"></p>
<p>Implementation of an inorder traversal will look like this:</p>
<pre><code class="language-cpp">void printInOrder(node* root)
{
  if(!root)
    return;
  printInOrder(root->left);
  cout &#x3C;&#x3C; root->val &#x3C;&#x3C; " ";
  printInOrder(root->right);
}
</code></pre>
<p>Now, we have everything we need to build and traverse a BST.</p>
<p>Here's an example of a BST using our <code>add</code> and <code>printInOrder</code> functions.</p>
<pre><code class="language-cpp">node* root = 0;
add(root, 10);
add(root, 15);
add(root, 8);
add(root, 18);
printInOrder(root);
</code></pre>
<blockquote>
<p>Output: <code>8 10 15 18</code></p>
</blockquote>
<p>As we can see, the <code>add</code> function adds new nodes to the tree and <code>printInOrder</code> function traverses the tree starting from the left-most node.</p>
<h2>Height of tree</h2>
<p>Every tree has a height. The tree in the previous image has a height of 4. The <em>deeper</em> the tree grows, the height increases. The algorithm for finding the height can be implemented recursively or with a loop. I prefer the recursive algorithm, which uses divide and conquer.</p>
<pre><code class="language-cpp">int getHeight(node* head)
{
  if(!head)
    return 0;

  /* get height of left and right nodes */
  int left = getHeight(head->left);
  int right = getHeight(head->right);

  /* get the maximum of the left and right nodes and add to it height of current node */
  return max(left, right) + 1;
}
</code></pre>
<p>The runtime of this algorithm is <code>O(n)</code> (n = number of nodes in tree), there are n subproblems and each subproblem takes a constant time (ignore recursive calls).</p>
<h2>Searching</h2>
<p>Breadth First Search (BFS) and Depth First Search (DFS) are two of the essential tree searching algorithms. They differ in their way of traversing the tree, but their implementation is very similar. In fact, if you change the Queue of BFS to a Stack, then you get DFS.</p>
<pre><code class="language-cpp">void BreadthFirstSearch(node* head)
{
  queue&#x3C;node*> q;
  q.push(head);
  cout &#x3C;&#x3C; "BFS: ";
  /* since it's a tree and not a graph, a visited set is unnecessary */
  while(!q.empty())
  {
    node* temp = q.front();
    q.pop();
    cout &#x3C;&#x3C; temp->val &#x3C;&#x3C; " ";
    if(temp->left)
      q.push(temp->left);
    if(temp->right)
      q.push(temp->right);
  }
  cout &#x3C;&#x3C; endl;
}
</code></pre>
<p><a href="https://repl.it/@manlai1025/DFS-and-BFS-in-BST">Here</a> is the complete code, which contains all the algorithms covered here.</p></div></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-blog-post-js","jsonName":"bst-ee1","path":"/bst"};window.dataPath="292/path---bst-ee-1-330-4ntZixYenU4jv0Ib2FqcDfFTeH8";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-222f29cc36792ce09b0f.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js.843d075df3c042fb76ca.css","/component---src-templates-blog-post-js-ea0b0e9e48edfbee761b.js"],"component---src-pages-404-js":["/component---src-pages-404-js.843d075df3c042fb76ca.css","/component---src-pages-404-js-8671f04b55c906589db8.js"],"component---src-pages-about-js":["/component---src-pages-about-js.843d075df3c042fb76ca.css","/component---src-pages-about-js-5c8d79bf5d3a31e2217b.js"],"component---src-pages-blog-js":["/component---src-pages-blog-js.099c92e3f6010eaacdf3.css","/component---src-pages-blog-js-ee79ea96659c731fc40d.js"],"component---src-pages-index-js":["/component---src-pages-index-js.843d075df3c042fb76ca.css","/component---src-pages-index-js-3cb4954758c906331bdf.js"],"component---src-pages-projects-js":["/component---src-pages-projects-js.843d075df3c042fb76ca.css","/component---src-pages-projects-js-c74d99c35c3bd9eec7ef.js"],"pages-manifest":["/pages-manifest-6b254091b98b9ea4719e.js"]};/*]]>*/</script><script src="/webpack-runtime-45262e1a2370d384551a.js" async=""></script><script src="/app-222f29cc36792ce09b0f.js" async=""></script><script src="/0-f46980da95ff899b1c80.js" async=""></script><script src="/component---src-templates-blog-post-js-ea0b0e9e48edfbee761b.js" async=""></script></body></html>